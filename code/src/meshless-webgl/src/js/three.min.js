import * as THREE from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
var scene = new THREE.Scene(); //建立場景
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); //設置鏡頭，視角為透視模型(角度，長寬比，最近距離，最遠距離)
var renderer = new THREE.WebGLRenderer(); //建立渲染器
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );


var geometry = new THREE.BoxGeometry( 1, 1, 1 ); //建立立方體
var material = new THREE.MeshPhongMaterial({ color: '#ff0000' }); //賦予一個能夠對光源產生反應的材質
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );
camera.position.set(0, 0, 5) ;//避免相機與物件重疊所以移動相機的Z軸，也可寫成 camera.position.z = 5;

var ambientLight = new THREE.AmbientLight( '#0c0c0c' ); //建立環境光
scene.add( ambientLight ); //把環境光添加到場景


var spoltLight = new THREE.SpotLight( '#FF0000' ); //建立聚光燈spoltLight.position.set(3, 3, 3); // 設定光源位置
spoltLight.target = cube; // 設定光源目標
scene.add( spoltLight); //把聚光燈添加到場景

function animate() {
   requestAnimationFrame( animate );
   renderer.render( scene, camera ); // 渲染，需傳入場景和鏡頭
} 
animate();

cube.rotation.x += 0.01;
cube.rotation.y += 0.01;

export function shapeMatch(original, deformed) {
    const n = original.length;
    const cm0 = center(original);
    const cm  = center(deformed);

    // A = Σ (x_i - cm)(x0_i - cm0)^T
    let A = math.zeros(3, 3);
    for (let i = 0; i < n; i++) {
        const x  = subtractVec3(deformed[i], cm);
        const x0 = subtractVec3(original[i], cm0);
        A = addMatrix(A, outerProduct(x, x0));
    }

    // SVD decomposition
    const svd = numeric.svd(A);
    let R = math.multiply(svd.U, math.transpose(svd.V));

    // Prevent reflection
    if (math.det(R) < 0) {
        svd.V[2][0] *= -1;
        svd.V[2][1] *= -1;
        svd.V[2][2] *= -1;
        R = math.multiply(svd.U, math.transpose(svd.V));
    }

    // Apply transformation
    return original.map(p => addVec3(math.multiply(R, subtractVec3(p, cm0)), cm));
}

